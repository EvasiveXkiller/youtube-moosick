import { $$, $ } from '../resources/utilities/objectScan.utility.js';
import { Category, ConstantURLs, FlexColumnOffset } from '../enums.js';
import { Song } from '../resources/generalTypes/song.js';
import { Video } from '../resources/generalTypes/video.js';
import { Playlist } from '../resources/generalTypes/playlist.js';
import { Artist, ArtistExtended } from '../resources/generalTypes/artist.js';
import { ParsersExtended } from './parsersExtended.js';
import { WatchEndpointParams } from '../resources/etc/rawResultTypes/common.js';
import type {
	MusicResponsiveListItemFlexColumnRenderer,
	NextContinuationData,
} from '../resources/etc/rawResultTypes/common.js';
import { Album, AlbumExtended } from '../resources/generalTypes/album.js';
import type {
	GeneralFull,
	MusicResponsiveListItemRenderer,
	MusicShelfRenderer,
} from '../resources/etc/rawResultTypes/general/generalFull.js';
import type { Item } from '../blocks/item.js';
import { Unsorted, UnsortedFactory } from '../resources/generalTypes/unsorted.js';
import type { ContinuableResultBlueprint } from '../resources/generalTypes/continuableResult.js';

/**
 * Parser to deal with the output generated by the Moosick#search
 *
 * @remarks
 * Do not use this class directly, unless for tests purposes
 * @beta
 */
export class GeneralParser {
	/**
	 * Parses the search result based on the return results or supplied parameters
	 * @param context - The return results from axios
	 * @param searchType - The type of search request, if omitted it will be detected from the response
	 */
	public static parseSearchResult(context: GeneralFull): ContinuableResultBlueprint<Unsorted>;
	public static parseSearchResult<T extends Category.VIDEO>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<Video>;
	public static parseSearchResult<T extends Category.SONG>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<Song>;
	public static parseSearchResult<T extends Category.PLAYLIST>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<Playlist>;
	public static parseSearchResult<T extends Category.ARTIST>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<ArtistExtended>;
	public static parseSearchResult<T extends Category.ALBUM | Category.EP | Category.SINGLE>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<AlbumExtended>;
	public static parseSearchResult<T extends Category>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<Video | Song | Playlist | ArtistExtended | AlbumExtended | Unsorted>;
	// eslint-disable-next-line complexity
	static parseSearchResult<T extends Category>(context: GeneralFull, searchType?: T): ContinuableResultBlueprint<Item> {
		const isUnsorted = searchType == null;
		// prep all the parts
		const albums: AlbumExtended[] = [];
		const videos: Video[] = [];
		const playlists: Playlist[] = [];
		const artist: ArtistExtended[] = [];
		const songs: Song[] = [];
		const unsorted: (AlbumExtended | Video | Playlist | ArtistExtended | Song)[] = [];
		const continuation = searchType ? ($$('.nextContinuationData')(context) as NextContinuationData[])[0] : undefined;
		const musicShelf = $$('.musicShelfRenderer')(context) as MusicShelfRenderer[];
		for (const shelfItem of musicShelf) {
			const shelfContent = $$('.musicResponsiveListItemRenderer')(shelfItem) as MusicResponsiveListItemRenderer[];
			for (const item of shelfContent) {
				const flexColumnRenderer = $$('.musicResponsiveListItemFlexColumnRenderer')(item) as MusicResponsiveListItemFlexColumnRenderer[];
				const category = searchType ?? (flexColumnRenderer[FlexColumnOffset.ALT].text.runs[0].text).toUpperCase();
				switch (category) {
					case 'SONG': {
						const display = $('.musicResponsiveListItemFlexColumnRenderer')(item) as MusicResponsiveListItemFlexColumnRenderer;
						songs.push(Song.from({
							...ParsersExtended.flexSecondRowComplexParser(flexColumnRenderer[FlexColumnOffset.ALT].text.runs, Category.SONG, Boolean(searchType)),
							...GeneralParser.musicResponsiveListItemRendererParser(item),
							thumbnails: ParsersExtended.thumbnailParser(item),
							playlistId: $('.playlistId')(display) as string,
							params: WatchEndpointParams.WAEB,
						}));
						if (isUnsorted) {
							unsorted.push(songs[songs.length - 1]);
						}

						break;
					}

					case 'VIDEO': {
						videos.push(Video.from({
							...GeneralParser.musicResponsiveListItemRendererParser(item),
							...ParsersExtended.flexSecondRowComplexParser(flexColumnRenderer[FlexColumnOffset.ALT].text.runs, Category.VIDEO, Boolean(searchType)),
							thumbnails: ParsersExtended.thumbnailParser(item),
						}));
						if (isUnsorted) {
							unsorted.push(videos[videos.length - 1]);
						}

						break;
					}

					case 'PLAYLIST': {
						playlists.push(Playlist.from({
							name: $('.text')(flexColumnRenderer) as string,
							browseId: item.navigationEndpoint?.browseEndpoint?.browseId ?? '',
							...ParsersExtended.flexSecondRowComplexParser(flexColumnRenderer[FlexColumnOffset.ALT].text.runs, Category.PLAYLIST, Boolean(searchType)),
						}));
						if (isUnsorted) {
							unsorted.push(playlists[playlists.length - 1]);
						}

						break;
					}

					case 'ARTIST': {
						artist.push(ArtistExtended.from({
							name: flexColumnRenderer[FlexColumnOffset.MAIN].text.runs[FlexColumnOffset.ONLYRUN].text,
							browseId: item.navigationEndpoint?.browseEndpoint?.browseId ?? '',
							thumbnails: ParsersExtended.thumbnailParser(item),
							url: `${ConstantURLs.CHANNEL_URL}${item.navigationEndpoint?.browseEndpoint?.browseId ?? ''}`,
							...ParsersExtended.flexSecondRowComplexParser(flexColumnRenderer[FlexColumnOffset.ALT].text.runs, Category.ARTIST, Boolean(searchType)),
						}));
						if (isUnsorted) {
							unsorted.push(artist[artist.length - 1]);
						}

						break;
					}

					case 'ALBUM':
					case 'SINGLE':
					case 'EP': {
						albums.push(AlbumExtended.from({
							...ParsersExtended.flexSecondRowComplexParser(flexColumnRenderer[FlexColumnOffset.ALT].text.runs, Category.ALBUM, Boolean(searchType)),
							name: flexColumnRenderer[FlexColumnOffset.MAIN].text.runs[FlexColumnOffset.ONLYRUN].text,
							browseId: item.navigationEndpoint?.browseEndpoint?.browseId ?? '',
							url: `${ConstantURLs.CHANNEL_URL}${item.navigationEndpoint?.browseEndpoint?.browseId ?? ''}`,
							thumbnails: ParsersExtended.thumbnailParser(item),
						}));
						if (isUnsorted) {
							unsorted.push(albums[albums.length - 1]);
						}

						break;
					}

					default: {
						break;
					}
				}
			}
		}

		switch (searchType) {
			case Category.SONG: {
				return {
					result: songs,
					continuation,
				};
			}

			case Category.VIDEO: {
				return {
					result: videos,
					continuation,
				};
			}

			case Category.ALBUM: {
				return {
					result: albums,
					continuation,
				};
			}

			case Category.ARTIST: {
				return {
					result: artist,
					continuation,
				};
			}

			case Category.PLAYLIST: {
				return {
					result: playlists,
					continuation,
				};
			}

			case undefined:
			default: {
				const result = new UnsortedFactory().create(
					{
						albums,
						videos,
						playlists,
						artist,
						songs,
					},
				);

				result.push(...unsorted);

				return {
					result,
					continuation,
				};
			}
		}
	}

	/**
	 * Only works for video and song
	 */
	static musicResponsiveListItemRendererParser(musicResponsiveListItemRenderer: MusicResponsiveListItemRenderer) {
		const display = $('.musicResponsiveListItemFlexColumnRenderer')(musicResponsiveListItemRenderer) as MusicResponsiveListItemFlexColumnRenderer;
		const name = $('.text')(display) as string;
		const id = $('.videoId')(display) as string;
		const url = `https://www.youtube.com/watch?v=${id}`;
		return { name, url, videoId: id };
	}
}
