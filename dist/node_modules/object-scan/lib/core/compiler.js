import { __exports as compiler } from '../../../../_virtual/compiler.js_commonjs-exports';
export { __exports as default } from '../../../../_virtual/compiler.js_commonjs-exports';
import './parser.js';
import '../generic/iterator.js';
import '../generic/traverser.js';
import '../generic/helper.js';
import './wildcard.js';
import { __exports as parser$1 } from '../../../../_virtual/parser.js_commonjs-exports';
import { __exports as helper } from '../../../../_virtual/helper.js_commonjs-exports';
import { __exports as wildcard } from '../../../../_virtual/wildcard.js_commonjs-exports';
import { __exports as traverser$1 } from '../../../../_virtual/traverser.js_commonjs-exports';
import { __exports as iterator$1 } from '../../../../_virtual/iterator.js_commonjs-exports';

/* compile needles to hierarchical map object */
const parser = parser$1;

const iterator = iterator$1;

const traverser = traverser$1;

const {
  defineProperty
} = helper;

const {
  Wildcard
} = wildcard;

const COUNTER = Symbol('counter');
const LEAF = Symbol('leaf');

const markLeaf = (input, match, readonly) => defineProperty(input, LEAF, match, readonly);

const isLeaf = input => LEAF in input;

const isMatch = input => input !== undefined && input[LEAF] === true;

compiler.isLeaf = isLeaf;
compiler.isMatch = isMatch;
const HAS_MATCHES = Symbol('has-matches');

const setHasMatches = input => defineProperty(input, HAS_MATCHES, true);

const hasMatches = input => input[HAS_MATCHES] === true;

compiler.hasMatches = hasMatches;

const merge = (input, symbol, value) => {
  if (input[symbol] === undefined) {
    defineProperty(input, symbol, []);
  }

  if (!input[symbol].includes(value)) {
    input[symbol].push(value);
  }
};

const LEAF_NEEDLES = Symbol('leaf-needles');

const addLeafNeedle = (input, needle) => merge(input, LEAF_NEEDLES, needle);

const getLeafNeedles = input => input[LEAF_NEEDLES] || [];

compiler.getLeafNeedles = getLeafNeedles;
const LEAF_NEEDLES_EXCLUDE = Symbol('leaf-needles-exclude');

const addLeafNeedleExclude = (input, needle) => merge(input, LEAF_NEEDLES_EXCLUDE, needle);

const getLeafNeedlesExclude = input => input[LEAF_NEEDLES_EXCLUDE] || [];

compiler.getLeafNeedlesExclude = getLeafNeedlesExclude;
const LEAF_NEEDLES_MATCH = Symbol('leaf-needles-match');

const addLeafNeedleMatch = (input, needle) => merge(input, LEAF_NEEDLES_MATCH, needle);

const getLeafNeedlesMatch = input => input[LEAF_NEEDLES_MATCH] || [];

compiler.getLeafNeedlesMatch = getLeafNeedlesMatch;
const NEEDLES = Symbol('needles');

const addNeedle = (input, needle) => merge(input, NEEDLES, needle);

const getNeedles = input => input[NEEDLES];

compiler.getNeedles = getNeedles;
const INDEX = Symbol('index');

const setIndex = (input, index, readonly) => defineProperty(input, INDEX, index, readonly);

const getIndex = input => input[INDEX];

compiler.getIndex = getIndex;
const ORDER = Symbol('order');

const setOrder = (input, order) => defineProperty(input, ORDER, order);

const getOrder = input => input[ORDER];

compiler.getOrder = getOrder;
const WILDCARD = Symbol('wildcard');

const setWildcard = (input, wildcard) => defineProperty(input, WILDCARD, wildcard);

const getWildcard = input => input[WILDCARD];

compiler.getWildcard = getWildcard;
const VALUES = Symbol('values');

const setValues = (input, entries) => defineProperty(input, VALUES, entries);

const getValues = input => input[VALUES];

compiler.getValues = getValues;

compiler.matchedBy = searches => Array.from(new Set([].concat(...searches.map(e => getLeafNeedlesMatch(e)))));

compiler.excludedBy = searches => Array.from(new Set([].concat(...searches.map(e => getLeafNeedlesExclude(e)))));

compiler.traversedBy = searches => Array.from(new Set([].concat(...searches.map(e => getNeedles(e)))));

compiler.isLastLeafMatch = searches => {
  let maxLeafIndex = Number.MIN_SAFE_INTEGER;
  let maxLeaf = null;

  for (let idx = 0, len = searches.length; idx < len; idx += 1) {
    const s = searches[idx];
    const index = getIndex(s);

    if (index !== undefined && index > maxLeafIndex) {
      maxLeafIndex = index;
      maxLeaf = s;
    }
  }

  return maxLeaf !== null && isMatch(maxLeaf);
};

const iterate = (tower, needle, tree, {
  onAdd,
  onFin
}) => {
  const stack = [[[tower, null]]];
  const wildcards = [];
  let excluded = false;
  iterator.iterate(tree, (type, wc) => {
    if (type === 'RM') {
      if (wc.excluded === true) {
        excluded = false;
      }

      stack.pop();
      wildcards.pop();
    } else if (type === 'ADD') {
      if (wc.excluded === true) {
        if (excluded) {
          throw new Error(`Redundant Exclusion: "${needle}"`);
        }

        excluded = true;
      }

      const toAdd = [];
      const wcParent = wildcards[wildcards.length - 1];
      stack[stack.length - 1].forEach(([cur]) => onAdd(cur, wc, wcParent, e => toAdd.push([e, cur])));
      stack.push(toAdd);
      wildcards.push(wc);
    } else {
      stack[stack.length - 1].filter(([cur]) => cur !== tower).forEach(([cur, parent]) => onFin(cur, wc[wc.length - 1], parent, excluded));
    }
  });
};

const applyNeedle = (tower, needle, tree, ctx) => {
  iterate(tower, needle, tree, {
    onAdd: (cur, wc, wcParent, next) => {
      addNeedle(cur, needle);
      const redundantRecursion = wcParent !== undefined && wc.isStarRec && wc.value === wcParent.value;

      if (redundantRecursion && ctx.strict) {
        throw new Error(`Redundant Recursion: "${needle}"`);
      }

      if (!redundantRecursion) {
        if (!(wc.value in cur)) {
          const child = {}; // eslint-disable-next-line no-param-reassign

          cur[wc.value] = child;

          if (ctx.orderByNeedles) {
            setOrder(child, ctx[COUNTER]);
          }

          setWildcard(child, wc);
        }

        next(cur[wc.value]);
      }

      if (wc.isStarRec) {
        next(cur);
      }
    },
    onFin: (cur, wc, parent, excluded) => {
      if (ctx.strict) {
        if (wc.isSimpleStarRec) {
          const unnecessary = Object.keys(parent).filter(k => !['**', ''].includes(k));

          if (unnecessary.length !== 0) {
            throw new Error(`Needle Target Invalidated: "${parent[unnecessary[0]][NEEDLES][0]}" by "${needle}"`);
          }
        }
      }

      addNeedle(cur, needle);

      if (ctx.strict && LEAF_NEEDLES in cur) {
        throw new Error(`Redundant Needle Target: "${cur[LEAF_NEEDLES][0]}" vs "${needle}"`);
      }

      addLeafNeedle(cur, needle, ctx.strict);

      if (excluded) {
        addLeafNeedleExclude(cur, needle);
      } else {
        addLeafNeedleMatch(cur, needle);
      }

      markLeaf(cur, !excluded, ctx.strict);
      setIndex(cur, ctx[COUNTER], ctx.strict);
      ctx[COUNTER] += 1;
    }
  });
};

const finalizeTower = tower => {
  const matches = [];
  let lastDepth = -1;
  traverser.traverse(tower, (type, obj, depth) => {
    if (type === 'EXIT') {
      const isUp = lastDepth === depth + 1;

      if (isUp && matches[lastDepth] === true || isMatch(obj)) {
        matches[depth] = true;
        setHasMatches(obj);
      }

      if (isUp) {
        matches[lastDepth] = false;
      }

      setValues(obj, Object.values(obj).reverse());
      lastDepth = depth;
    }
  });
};

compiler.compile = (needles, ctx) => {
  const tower = {};
  ctx[COUNTER] = 0;

  for (let idx = 0; idx < needles.length; idx += 1) {
    const needle = needles[idx];
    const tree = [parser.parse(needle, ctx)];
    applyNeedle(tower, needle, tree, ctx);
  }

  setWildcard(tower, new Wildcard('*', false));
  finalizeTower(tower);
  return tower;
};
//# sourceMappingURL=compiler.js.map
