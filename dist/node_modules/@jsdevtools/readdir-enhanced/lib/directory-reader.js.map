{"version":3,"file":"directory-reader.js","sources":["../../../../../node_modules/@jsdevtools/readdir-enhanced/lib/directory-reader.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectoryReader = void 0;\nconst path = require(\"path\");\nconst stream_1 = require(\"stream\");\nconst call_1 = require(\"./call\");\nconst normalize_options_1 = require(\"./normalize-options\");\nconst stat_1 = require(\"./stat\");\n/**\n * Asynchronously reads the contents of a directory and streams the results\n * via a `ReadableStream`.\n *\n * @internal\n */\nclass DirectoryReader {\n    /**\n     * @param dir - The absolute or relative directory path to read\n     * @param [options] - User-specified options, if any (see `normalizeOptions()`)\n     * @param facade - sync or async function implementations\n     * @param emit - Indicates whether the reader should emit \"file\", \"directory\", and \"symlink\" events.\n     */\n    constructor(dir, options, facade, emit = false) {\n        this.options = normalize_options_1.normalizeOptions(options, facade, emit);\n        // Indicates whether we should keep reading\n        // This is set false if stream.Readable.push() returns false.\n        this.shouldRead = true;\n        // The directories to read\n        // (initialized with the top-level directory)\n        this.queue = [{\n                path: dir,\n                basePath: this.options.basePath,\n                depth: 0\n            }];\n        // The number of directories that are currently being processed\n        this.pending = 0;\n        // The data that has been read, but not yet emitted\n        this.buffer = [];\n        this.stream = new stream_1.Readable({ objectMode: true });\n        this.stream._read = () => {\n            // Start (or resume) reading\n            this.shouldRead = true;\n            // If we have data in the buffer, then send the next chunk\n            if (this.buffer.length > 0) {\n                this.pushFromBuffer();\n            }\n            // If we have directories queued, then start processing the next one\n            if (this.queue.length > 0) {\n                this.readNextDirectory();\n            }\n            this.checkForEOF();\n        };\n    }\n    /**\n     * Reads the next directory in the queue\n     */\n    readNextDirectory() {\n        let { facade } = this.options;\n        let dir = this.queue.shift();\n        this.pending++;\n        // Read the directory listing\n        call_1.safeCall(facade.fs.readdir, dir.path, (err, items) => {\n            if (err) {\n                // fs.readdir threw an error\n                this.emit(\"error\", err);\n                return this.finishedReadingDirectory();\n            }\n            try {\n                // Process each item in the directory (simultaneously, if async)\n                facade.forEach(items, this.processItem.bind(this, dir), this.finishedReadingDirectory.bind(this, dir));\n            }\n            catch (err2) {\n                // facade.forEach threw an error\n                // (probably because fs.readdir returned an invalid result)\n                this.emit(\"error\", err2);\n                this.finishedReadingDirectory();\n            }\n        });\n    }\n    /**\n     * This method is called after all items in a directory have been processed.\n     *\n     * NOTE: This does not necessarily mean that the reader is finished, since there may still\n     * be other directories queued or pending.\n     */\n    finishedReadingDirectory() {\n        this.pending--;\n        if (this.shouldRead) {\n            // If we have directories queued, then start processing the next one\n            if (this.queue.length > 0) {\n                this.readNextDirectory();\n            }\n            this.checkForEOF();\n        }\n    }\n    /**\n     * Determines whether the reader has finished processing all items in all directories.\n     * If so, then the \"end\" event is fired (via {@Readable#push})\n     */\n    checkForEOF() {\n        if (this.buffer.length === 0 && // The stuff we've already read\n            this.pending === 0 && // The stuff we're currently reading\n            this.queue.length === 0) { // The stuff we haven't read yet\n            // There's no more stuff!\n            this.stream.push(null);\n        }\n    }\n    /**\n     * Processes a single item in a directory.\n     *\n     * If the item is a directory, and `option.deep` is enabled, then the item will be added\n     * to the directory queue.\n     *\n     * If the item meets the filter criteria, then it will be emitted to the reader's stream.\n     *\n     * @param dir - A directory object from the queue\n     * @param item - The name of the item (name only, no path)\n     * @param done - A callback function that is called after the item has been processed\n     */\n    processItem(dir, item, done) {\n        let stream = this.stream;\n        let options = this.options;\n        let itemPath = dir.basePath + item;\n        let fullPath = path.join(dir.path, item);\n        // If `options.deep` is a number, and we've already recursed to the max depth,\n        // then there's no need to check fs.Stats to know if it's a directory.\n        // If `options.deep` is a function, then we'll need fs.Stats\n        let maxDepthReached = dir.depth >= options.recurseDepth;\n        // Do we need to call `fs.stat`?\n        let needStats = !maxDepthReached || // we need the fs.Stats to know if it's a directory\n            options.stats || // the user wants fs.Stats objects returned\n            options.recurseFnNeedsStats || // we need fs.Stats for the recurse function\n            options.filterFnNeedsStats || // we need fs.Stats for the filter function\n            stream.listenerCount(\"file\") || // we need the fs.Stats to know if it's a file\n            stream.listenerCount(\"directory\") || // we need the fs.Stats to know if it's a directory\n            stream.listenerCount(\"symlink\"); // we need the fs.Stats to know if it's a symlink\n        // If we don't need stats, then exit early\n        if (!needStats) {\n            if (this.filter({ path: itemPath })) {\n                this.pushOrBuffer({ data: itemPath });\n            }\n            return done();\n        }\n        // Get the fs.Stats object for this path\n        stat_1.stat(options.facade.fs, fullPath, (err, stats) => {\n            if (err) {\n                // fs.stat threw an error\n                this.emit(\"error\", err);\n                return done();\n            }\n            try {\n                // Add the item's path to the fs.Stats object\n                // The base of this path, and its separators are determined by the options\n                // (i.e. options.basePath and options.sep)\n                stats.path = itemPath;\n                // Add depth of the path to the fs.Stats object for use this in the filter function\n                stats.depth = dir.depth;\n                if (this.shouldRecurse(stats, maxDepthReached)) {\n                    // Add this subdirectory to the queue\n                    this.queue.push({\n                        path: fullPath,\n                        basePath: itemPath + options.sep,\n                        depth: dir.depth + 1,\n                    });\n                }\n                // Determine whether this item matches the filter criteria\n                if (this.filter(stats)) {\n                    this.pushOrBuffer({\n                        data: options.stats ? stats : itemPath,\n                        file: stats.isFile(),\n                        directory: stats.isDirectory(),\n                        symlink: stats.isSymbolicLink(),\n                    });\n                }\n                done();\n            }\n            catch (err2) {\n                // An error occurred while processing the item\n                // (probably during a user-specified function, such as options.deep, options.filter, etc.)\n                this.emit(\"error\", err2);\n                done();\n            }\n        });\n    }\n    /**\n     * Pushes the given chunk of data to the stream, or adds it to the buffer,\n     * depending on the state of the stream.\n     */\n    pushOrBuffer(chunk) {\n        // Add the chunk to the buffer\n        this.buffer.push(chunk);\n        // If we're still reading, then immediately emit the next chunk in the buffer\n        // (which may or may not be the chunk that we just added)\n        if (this.shouldRead) {\n            this.pushFromBuffer();\n        }\n    }\n    /**\n     * Immediately pushes the next chunk in the buffer to the reader's stream.\n     * The \"data\" event will always be fired (via `Readable.push()`).\n     * In addition, the \"file\", \"directory\", and/or \"symlink\" events may be fired,\n     * depending on the type of properties of the chunk.\n     */\n    pushFromBuffer() {\n        let stream = this.stream;\n        let chunk = this.buffer.shift();\n        // Stream the data\n        try {\n            this.shouldRead = stream.push(chunk.data);\n        }\n        catch (err) {\n            this.emit(\"error\", err);\n        }\n        if (this.options.emit) {\n            // Also emit specific events, based on the type of chunk\n            chunk.file && this.emit(\"file\", chunk.data);\n            chunk.symlink && this.emit(\"symlink\", chunk.data);\n            chunk.directory && this.emit(\"directory\", chunk.data);\n        }\n    }\n    /**\n     * Determines whether the given directory meets the user-specified recursion criteria.\n     * If the user didn't specify recursion criteria, then this function will default to true.\n     *\n     * @param stats - The directory's `Stats` object\n     * @param maxDepthReached - Whether we've already crawled the user-specified depth\n     */\n    shouldRecurse(stats, maxDepthReached) {\n        let { recurseFn } = this.options;\n        if (maxDepthReached) {\n            // We've already crawled to the maximum depth. So no more recursion.\n            return false;\n        }\n        else if (!stats.isDirectory()) {\n            // It's not a directory. So don't try to crawl it.\n            return false;\n        }\n        else if (recurseFn) {\n            try {\n                // Run the user-specified recursion criteria\n                return !!recurseFn(stats);\n            }\n            catch (err) {\n                // An error occurred in the user's code.\n                // In Sync and Async modes, this will return an error.\n                // In Streaming mode, we emit an \"error\" event, but continue processing\n                this.emit(\"error\", err);\n            }\n        }\n        else {\n            // No recursion function was specified, and we're within the maximum depth.\n            // So crawl this directory.\n            return true;\n        }\n    }\n    /**\n     * Determines whether the given item meets the user-specified filter criteria.\n     * If the user didn't specify a filter, then this function will always return true.\n     *\n     * @param stats - The item's `Stats` object, or an object with just a `path` property\n     */\n    filter(stats) {\n        let { filterFn } = this.options;\n        if (filterFn) {\n            try {\n                // Run the user-specified filter function\n                return !!filterFn(stats);\n            }\n            catch (err) {\n                // An error occurred in the user's code.\n                // In Sync and Async modes, this will return an error.\n                // In Streaming mode, we emit an \"error\" event, but continue processing\n                this.emit(\"error\", err);\n            }\n        }\n        else {\n            // No filter was specified, so match everything\n            return true;\n        }\n    }\n    /**\n     * Emits an event.  If one of the event listeners throws an error,\n     * then an \"error\" event is emitted.\n     */\n    emit(eventName, data) {\n        let stream = this.stream;\n        try {\n            stream.emit(eventName, data);\n        }\n        catch (err) {\n            if (eventName === \"error\") {\n                // Don't recursively emit \"error\" events.\n                // If the first one fails, then just throw\n                throw err;\n            }\n            else {\n                stream.emit(\"error\", err);\n            }\n        }\n    }\n}\nexports.DirectoryReader = DirectoryReader;\n//# sourceMappingURL=directory-reader.js.map"],"names":["require$$0","require$$1","require$$2","require$$3","require$$4"],"mappings":"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"}