import { __exports as fs$1 } from '../../../../../_virtual/fs.js_commonjs-exports';
export { __exports as default } from '../../../../../_virtual/fs.js_commonjs-exports';
import require$$0 from 'fs';
import '../call.js';
import { __exports as call } from '../../../../../_virtual/call.js_commonjs-exports';

Object.defineProperty(fs$1, "__esModule", { value: true });
fs$1.syncFS = void 0;
const fs = require$$0;
const call_1 = call;
/**
 * Synchronous versions of `fs` methods.
 *
 * @internal
 */
fs$1.syncFS = {
    /**
     * A facade around `fs.readdirSync()` that allows it to be called
     * the same way as `fs.readdir()`.
     */
    readdir(dir, callback) {
        // Make sure the callback is only called once
        callback = call_1.callOnce(callback);
        try {
            let items = fs.readdirSync(dir);
            callback(null, items);
        }
        catch (err) {
            callback(err, undefined);
        }
    },
    /**
     * A facade around `fs.statSync()` that allows it to be called
     * the same way as `fs.stat()`.
     */
    stat(path, callback) {
        // Make sure the callback is only called once
        callback = call_1.callOnce(callback);
        try {
            let stats = fs.statSync(path);
            callback(null, stats);
        }
        catch (err) {
            callback(err, undefined);
        }
    },
    /**
     * A facade around `fs.lstatSync()` that allows it to be called
     * the same way as `fs.lstat()`.
     */
    lstat(path, callback) {
        // Make sure the callback is only called once
        callback = call_1.callOnce(callback);
        try {
            let stats = fs.lstatSync(path);
            callback(null, stats);
        }
        catch (err) {
            callback(err, undefined);
        }
    },
};
//# sourceMappingURL=fs.js.map
