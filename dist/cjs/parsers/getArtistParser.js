"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetArtistParser = void 0;
const objectScan_utility_js_1 = require("../resources/utilities/objectScan.utility.js");
const thumbnails_js_1 = require("../resources/generalTypes/thumbnails.js");
const artist_js_1 = require("../resources/generalTypes/artist.js");
const enums_js_1 = require("../enums.js");
const artistURL_js_1 = require("../resources/resultTypes/artistURL.js");
/**
 * Parser to deal with the output generated by the Moosick#getArtist
 *
 * @remarks
 * Do not use this class directly, unless for tests purposes
 * @internal
 */
class GetArtistParser {
    static parseArtistURLPage(context) {
        const subHeader = (0, objectScan_utility_js_1.$)('.musicDescriptionShelfRenderer')(context);
        // Builds the header
        const header = artistURL_js_1.ArtistHeader.from({
            artistName: context.header.musicImmersiveHeaderRenderer.title.runs[enums_js_1.FlexColumnOffset.ONLYRUN].text,
            description: subHeader.description.runs[enums_js_1.FlexColumnOffset.ONLYRUN].text,
            // probably reduce the length of this access
            totalSubscribers: context.header.musicImmersiveHeaderRenderer.subscriptionButton.subscribeButtonRenderer.subscriberCountWithSubscribeText.runs[enums_js_1.FlexColumnOffset.ONLYRUN].text,
            thumbnails: this.parseMusicThumbnailRenderer((0, objectScan_utility_js_1.$)('.musicThumbnailRenderer')(context)),
        });
        const albums = [];
        const singles = [];
        const videos = [];
        // Gets the carousel, there should be 5 of them
        const twoRowRenderer = (0, objectScan_utility_js_1.$$)('.musicCarouselShelfRenderer')(context);
        for (const itemRenderer of twoRowRenderer) {
            // Gets the row name type
            const rowName = (0, objectScan_utility_js_1.$$)('.header .title .text')(itemRenderer)[0].toLowerCase();
            // Only parse the following, the others are not useful
            const validRows = ['albums', 'singles', 'videos'];
            if (!(validRows.includes(rowName))) {
                break;
            }
            // Gets the items in the carousel
            const musicItemRenderer = (0, objectScan_utility_js_1.$$)('.musicTwoRowItemRenderer')(itemRenderer);
            for (const blockRenderer of musicItemRenderer) {
                const runsInternal = blockRenderer.title.runs[enums_js_1.FlexColumnOffset.ONLYRUN].text;
                // eslint-disable-next-line default-case
                switch (rowName) {
                    case 'albums': {
                        albums.push(artistURL_js_1.Albums.from({
                            title: runsInternal,
                            browseId: blockRenderer.navigationEndpoint.browseEndpoint.browseId,
                            URL: `${enums_js_1.ConstantURLs.CHANNEL_URL}${blockRenderer.navigationEndpoint.browseEndpoint.browseId}`,
                            year: parseInt(blockRenderer.subtitle.runs[blockRenderer.subtitle.runs.length - 1].text, 10),
                            thumbnails: this.parseMusicThumbnailRenderer(blockRenderer.thumbnailRenderer.musicThumbnailRenderer),
                        }));
                        break;
                    }
                    case 'singles': {
                        singles.push(artistURL_js_1.Single.from({
                            title: runsInternal,
                            browseId: blockRenderer.navigationEndpoint.browseEndpoint.browseId,
                            URL: `${enums_js_1.ConstantURLs.CHANNEL_URL}${blockRenderer.navigationEndpoint.browseEndpoint.browseId}`,
                            year: parseInt(blockRenderer.subtitle.runs[blockRenderer.subtitle.runs.length - 1].text, 10),
                            thumbnails: this.parseMusicThumbnailRenderer(blockRenderer.thumbnailRenderer.musicThumbnailRenderer),
                        }));
                        break;
                    }
                    case 'videos': {
                        videos.push(artistURL_js_1.Videos.from({
                            title: runsInternal,
                            videoId: blockRenderer.navigationEndpoint?.watchEndpoint?.videoId ?? '',
                            URL: `${enums_js_1.ConstantURLs.VIDEOLINK}${blockRenderer.navigationEndpoint?.watchEndpoint?.videoId ?? ''}`,
                            playlistId: blockRenderer.navigationEndpoint.watchEndpoint?.playlistId ?? '',
                            views: parseInt(blockRenderer.subtitle.runs[blockRenderer.subtitle.runs.length - 1].text, 10),
                            thumbnails: this.parseMusicThumbnailRenderer(blockRenderer.thumbnailRenderer.musicThumbnailRenderer),
                            author: this.parseArtistFromVideos(blockRenderer.subtitle.runs),
                        }));
                        break;
                    }
                }
            }
        }
        const artistContent = artistURL_js_1.ArtistContent.from({
            albums,
            single: singles,
            videos,
        });
        return artistURL_js_1.ArtistURL.from({
            headers: header,
            artistContents: artistContent,
        });
    }
    /**
     * Parses thumbnails
     * @param musicThumbnailRenderer - Thumbnail renderer
     * @internal
     */
    static parseMusicThumbnailRenderer(musicThumbnailRenderer) {
        const thumbnailsProcessed = [];
        musicThumbnailRenderer.thumbnail.thumbnails.forEach((item) => {
            thumbnailsProcessed.push(thumbnails_js_1.Thumbnails.from({
                url: item.url,
                width: item.width,
                height: item.height,
            }));
        });
        return thumbnailsProcessed;
    }
    /**
     * Parses artist from subtitle renderer
     * @param subtitleRenderer - The subtitle run
     * @internal
     */
    static parseArtistFromVideos(subtitleRenderer) {
        const delimiter = ' â€¢ ';
        const positions = subtitleRenderer.flatMap((text, i) => text.text === delimiter ? i : []);
        const artistOnly = subtitleRenderer.slice(0, positions[enums_js_1.FlexSecondRowOffset.ARTIST]);
        return artistOnly.map((element) => (artist_js_1.Artist.from({
            name: element.text,
            browseId: element.navigationEndpoint?.browseEndpoint?.browseId ?? '',
            url: `${enums_js_1.ConstantURLs.CHANNEL_URL}${element.navigationEndpoint?.browseEndpoint?.browseId ?? ''}`,
        })));
    }
}
exports.GetArtistParser = GetArtistParser;
//# sourceMappingURL=getArtistParser.js.map